"""Property-based tests for CronScheduler.

**Feature: automated-daily-logging, Property 11: Platform-specific commands are syntactically correct**
**Validates: Requirements 5.4, 5.5**
"""

import pytest
import re
from unittest.mock import Mock, patch, MagicMock
from hypothesis import given, strategies as st, settings, assume
from datetime import datetime, timedelta

from talkbut.scheduling.cron_scheduler import CronScheduler


# Strategy for generating valid time strings in HH:MM format
@st.composite
def valid_time_string(draw):
    """Generate valid time strings in HH:MM format."""
    hour = draw(st.integers(min_value=0, max_value=23))
    minute = draw(st.integers(min_value=0, max_value=59))
    return f"{hour:02d}:{minute:02d}"


# Strategy for generating valid command strings
@st.composite
def valid_command_string(draw):
    """Generate valid command strings for cron."""
    # Generate realistic command paths and arguments
    commands = [
        "/usr/bin/python3 /path/to/script.py",
        "/usr/local/bin/talkbut log",
        "python -m talkbut.cli.main log",
        "/home/user/.local/bin/talkbut log --author user",
    ]
    return draw(st.sampled_from(commands))


def is_valid_cron_expression(cron_line: str) -> bool:
    """
    Validate that a cron line has correct syntax.
    
    A valid cron line should have the format:
    minute hour day_of_month month day_of_week command
    
    Where:
    - minute: 0-59
    - hour: 0-23
    - day_of_month: 1-31 or *
    - month: 1-12 or *
    - day_of_week: 0-7 or *
    """
    # Remove the marker comment if present
    if "#" in cron_line:
        cron_line = cron_line.split("#")[0].strip()
    
    parts = cron_line.split()
    
    # Must have at least 6 parts (5 time fields + command)
    if len(parts) < 6:
        return False
    
    minute, hour, day_of_month, month, day_of_week = parts[:5]
    command = " ".join(parts[5:])
    
    # Validate minute (0-59 or *)
    if minute != "*":
        try:
            min_val = int(minute)
            if not (0 <= min_val <= 59):
                return False
        except ValueError:
            return False
    
    # Validate hour (0-23 or *)
    if hour != "*":
        try:
            hour_val = int(hour)
            if not (0 <= hour_val <= 23):
                return False
        except ValueError:
            return False
    
    # Validate day_of_month (1-31 or *)
    if day_of_month != "*":
        try:
            dom_val = int(day_of_month)
            if not (1 <= dom_val <= 31):
                return False
        except ValueError:
            return False
    
    # Validate month (1-12 or *)
    if month != "*":
        try:
            month_val = int(month)
            if not (1 <= month_val <= 12):
                return False
        except ValueError:
            return False
    
    # Validate day_of_week (0-7 or *)
    if day_of_week != "*":
        try:
            dow_val = int(day_of_week)
            if not (0 <= dow_val <= 7):
                return False
        except ValueError:
            return False
    
    # Command must not be empty
    if not command.strip():
        return False
    
    return True


class TestCronSchedulerProperties:
    """Property-based tests for CronScheduler."""
    
    @given(time=valid_time_string(), command=valid_command_string())
    @settings(max_examples=100, deadline=None)
    def test_property_cron_commands_are_syntactically_correct(self, time, command):
        """
        Property 11: Platform-specific commands are syntactically correct.
        
        For any valid time and command, the cron expression generated by CronScheduler
        should be syntactically correct according to cron syntax rules.
        
        **Feature: automated-daily-logging, Property 11: Platform-specific commands are syntactically correct**
        **Validates: Requirements 5.4, 5.5**
        """
        scheduler = CronScheduler()
        
        # Mock subprocess to capture the cron line without actually modifying crontab
        captured_cron_line = None
        
        def mock_popen(*args, **kwargs):
            """Mock Popen to capture the cron line."""
            nonlocal captured_cron_line
            mock_process = MagicMock()
            mock_process.returncode = 0
            
            def mock_communicate(input=None):
                nonlocal captured_cron_line
                if input:
                    # Extract the new cron line (last non-empty line)
                    lines = [line for line in input.split('\n') if line.strip()]
                    if lines:
                        captured_cron_line = lines[-1]
                return ("", "")
            
            mock_process.communicate = mock_communicate
            return mock_process
        
        def mock_run(*args, **kwargs):
            """Mock run to return empty crontab."""
            mock_result = MagicMock()
            mock_result.returncode = 0
            mock_result.stdout = ""
            return mock_result
        
        with patch('subprocess.Popen', side_effect=mock_popen), \
             patch('subprocess.run', side_effect=mock_run):
            
            # Create the job
            result = scheduler.create_job(time, command)
            
            # Verify operation succeeded
            assert result is True, f"create_job failed for time={time}, command={command}"
            
            # Property: The generated cron line should be syntactically correct
            assert captured_cron_line is not None, \
                "No cron line was captured"
            
            assert is_valid_cron_expression(captured_cron_line), \
                f"Generated cron line is not syntactically correct: '{captured_cron_line}'"
    
    @given(time=valid_time_string(), command=valid_command_string())
    @settings(max_examples=100, deadline=None)
    def test_property_cron_time_fields_match_input(self, time, command):
        """
        Property 11: Platform-specific commands are syntactically correct.
        
        For any valid time, the cron expression should have minute and hour fields
        that match the input time.
        
        **Feature: automated-daily-logging, Property 11: Platform-specific commands are syntactically correct**
        **Validates: Requirements 5.4, 5.5**
        """
        scheduler = CronScheduler()
        
        # Parse input time
        hour_input, minute_input = map(int, time.split(':'))
        
        # Mock subprocess to capture the cron line
        captured_cron_line = None
        
        def mock_popen(*args, **kwargs):
            """Mock Popen to capture the cron line."""
            nonlocal captured_cron_line
            mock_process = MagicMock()
            mock_process.returncode = 0
            
            def mock_communicate(input=None):
                nonlocal captured_cron_line
                if input:
                    lines = [line for line in input.split('\n') if line.strip()]
                    if lines:
                        captured_cron_line = lines[-1]
                return ("", "")
            
            mock_process.communicate = mock_communicate
            return mock_process
        
        def mock_run(*args, **kwargs):
            """Mock run to return empty crontab."""
            mock_result = MagicMock()
            mock_result.returncode = 0
            mock_result.stdout = ""
            return mock_result
        
        with patch('subprocess.Popen', side_effect=mock_popen), \
             patch('subprocess.run', side_effect=mock_run):
            
            # Create the job
            result = scheduler.create_job(time, command)
            
            # Verify operation succeeded
            assert result is True, f"create_job failed for time={time}"
            
            # Property: The cron expression should have correct time fields
            assert captured_cron_line is not None, "No cron line was captured"
            
            # Extract minute and hour from cron line
            parts = captured_cron_line.split()
            assert len(parts) >= 5, f"Cron line has insufficient fields: '{captured_cron_line}'"
            
            cron_minute = int(parts[0])
            cron_hour = int(parts[1])
            
            assert cron_minute == minute_input, \
                f"Cron minute {cron_minute} does not match input minute {minute_input}"
            assert cron_hour == hour_input, \
                f"Cron hour {cron_hour} does not match input hour {hour_input}"
    
    @given(time=valid_time_string(), command=valid_command_string())
    @settings(max_examples=100, deadline=None)
    def test_property_cron_daily_schedule_format(self, time, command):
        """
        Property 11: Platform-specific commands are syntactically correct.
        
        For any valid time, the cron expression should use the daily schedule format
        (minute hour * * *) where day_of_month, month, and day_of_week are wildcards.
        
        **Feature: automated-daily-logging, Property 11: Platform-specific commands are syntactically correct**
        **Validates: Requirements 5.4, 5.5**
        """
        scheduler = CronScheduler()
        
        # Mock subprocess to capture the cron line
        captured_cron_line = None
        
        def mock_popen(*args, **kwargs):
            """Mock Popen to capture the cron line."""
            nonlocal captured_cron_line
            mock_process = MagicMock()
            mock_process.returncode = 0
            
            def mock_communicate(input=None):
                nonlocal captured_cron_line
                if input:
                    lines = [line for line in input.split('\n') if line.strip()]
                    if lines:
                        captured_cron_line = lines[-1]
                return ("", "")
            
            mock_process.communicate = mock_communicate
            return mock_process
        
        def mock_run(*args, **kwargs):
            """Mock run to return empty crontab."""
            mock_result = MagicMock()
            mock_result.returncode = 0
            mock_result.stdout = ""
            return mock_result
        
        with patch('subprocess.Popen', side_effect=mock_popen), \
             patch('subprocess.run', side_effect=mock_run):
            
            # Create the job
            result = scheduler.create_job(time, command)
            
            # Verify operation succeeded
            assert result is True, f"create_job failed for time={time}"
            
            # Property: The cron expression should use daily format (* * *)
            assert captured_cron_line is not None, "No cron line was captured"
            
            parts = captured_cron_line.split()
            assert len(parts) >= 5, f"Cron line has insufficient fields: '{captured_cron_line}'"
            
            # Fields 3, 4, 5 (day_of_month, month, day_of_week) should be wildcards
            day_of_month = parts[2]
            month = parts[3]
            day_of_week = parts[4]
            
            assert day_of_month == "*", \
                f"Day of month should be '*' for daily schedule, got '{day_of_month}'"
            assert month == "*", \
                f"Month should be '*' for daily schedule, got '{month}'"
            assert day_of_week == "*", \
                f"Day of week should be '*' for daily schedule, got '{day_of_week}'"
    
    @given(time=valid_time_string(), command=valid_command_string())
    @settings(max_examples=100, deadline=None)
    def test_property_cron_command_is_preserved(self, time, command):
        """
        Property 11: Platform-specific commands are syntactically correct.
        
        For any valid command, the cron expression should preserve the command
        exactly as provided (possibly with a marker comment).
        
        **Feature: automated-daily-logging, Property 11: Platform-specific commands are syntactically correct**
        **Validates: Requirements 5.4, 5.5**
        """
        scheduler = CronScheduler()
        
        # Mock subprocess to capture the cron line
        captured_cron_line = None
        
        def mock_popen(*args, **kwargs):
            """Mock Popen to capture the cron line."""
            nonlocal captured_cron_line
            mock_process = MagicMock()
            mock_process.returncode = 0
            
            def mock_communicate(input=None):
                nonlocal captured_cron_line
                if input:
                    lines = [line for line in input.split('\n') if line.strip()]
                    if lines:
                        captured_cron_line = lines[-1]
                return ("", "")
            
            mock_process.communicate = mock_communicate
            return mock_process
        
        def mock_run(*args, **kwargs):
            """Mock run to return empty crontab."""
            mock_result = MagicMock()
            mock_result.returncode = 0
            mock_result.stdout = ""
            return mock_result
        
        with patch('subprocess.Popen', side_effect=mock_popen), \
             patch('subprocess.run', side_effect=mock_run):
            
            # Create the job
            result = scheduler.create_job(time, command)
            
            # Verify operation succeeded
            assert result is True, f"create_job failed for command={command}"
            
            # Property: The command should be preserved in the cron line
            assert captured_cron_line is not None, "No cron line was captured"
            
            # The command should appear in the cron line
            assert command in captured_cron_line, \
                f"Command '{command}' not found in cron line: '{captured_cron_line}'"
    
    @given(time=valid_time_string())
    @settings(max_examples=100, deadline=None)
    def test_property_cron_marker_is_present(self, time):
        """
        Property 11: Platform-specific commands are syntactically correct.
        
        For any valid time, the cron expression should include the TalkBut marker
        comment for identification.
        
        **Feature: automated-daily-logging, Property 11: Platform-specific commands are syntactically correct**
        **Validates: Requirements 5.4, 5.5**
        """
        scheduler = CronScheduler()
        command = "/usr/local/bin/talkbut log"
        
        # Mock subprocess to capture the cron line
        captured_cron_line = None
        
        def mock_popen(*args, **kwargs):
            """Mock Popen to capture the cron line."""
            nonlocal captured_cron_line
            mock_process = MagicMock()
            mock_process.returncode = 0
            
            def mock_communicate(input=None):
                nonlocal captured_cron_line
                if input:
                    lines = [line for line in input.split('\n') if line.strip()]
                    if lines:
                        captured_cron_line = lines[-1]
                return ("", "")
            
            mock_process.communicate = mock_communicate
            return mock_process
        
        def mock_run(*args, **kwargs):
            """Mock run to return empty crontab."""
            mock_result = MagicMock()
            mock_result.returncode = 0
            mock_result.stdout = ""
            return mock_result
        
        with patch('subprocess.Popen', side_effect=mock_popen), \
             patch('subprocess.run', side_effect=mock_run):
            
            # Create the job
            result = scheduler.create_job(time, command)
            
            # Verify operation succeeded
            assert result is True, f"create_job failed for time={time}"
            
            # Property: The marker should be present in the cron line
            assert captured_cron_line is not None, "No cron line was captured"
            
            assert scheduler.TALKBUT_MARKER in captured_cron_line, \
                f"TalkBut marker '{scheduler.TALKBUT_MARKER}' not found in cron line: '{captured_cron_line}'"
